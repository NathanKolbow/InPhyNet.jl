var documenterSearchIndex = {"docs":
[{"location":"guide/estgts/","page":"Using estimated gene trees and SNaQ","title":"Using estimated gene trees and SNaQ","text":"Say we have estimated gene trees in the file my-est-gts.treefile. First, we use MSCquartets in R to check for potential hybrid relationships and to inform the subset decomposition algorithm later on.","category":"page"},{"location":"guide/estgts/","page":"Using estimated gene trees and SNaQ","title":"Using estimated gene trees and SNaQ","text":"Note: MSCquartets is prohibitively slow for many, many taxa, so we are working on porting its methods to julia where they can run much faster.","category":"page"},{"location":"guide/estgts/","page":"Using estimated gene trees and SNaQ","title":"Using estimated gene trees and SNaQ","text":"library(MSCquartets)\nlibrary(ape)\n\ngtrees <- read.tree(file=\"my-est-gts.treefile\")\ntaxanames <- taxonNames(gtrees)\nQT <- quartetTable(gtrees,taxanames)\nRQT <- quartetTableResolved(QT)\npTable <- quartetTreeTestInd(RQT,\"T3\")\nHolmBonferroni(pTable,\"T3\",cutoff)\nwrite.csv(getHBpTable(treefile, cutoff=cutoff), \"quartets.dat\")","category":"page"},{"location":"guide/estgts/","page":"Using estimated gene trees and SNaQ","title":"Using estimated gene trees and SNaQ","text":"The results from MSCquartets are now in the file quartets.dat.","category":"page"},{"location":"guide/estgts/","page":"Using estimated gene trees and SNaQ","title":"Using estimated gene trees and SNaQ","text":"Now we can do everything else in juila.","category":"page"},{"location":"guide/estgts/","page":"Using estimated gene trees and SNaQ","title":"Using estimated gene trees and SNaQ","text":"using PhyloNetworks, NetMerge\n\nmergednet = netnj(\"my-est-gts.treefile\", \"quartets.dat\")","category":"page"},{"location":"guide/estgts/","page":"Using estimated gene trees and SNaQ","title":"Using estimated gene trees and SNaQ","text":"Alternatively, if you want to make manual adjustments to the default pipeline, you can break the pipeline down as below. In this example, the starting tree for SNaQ is estimated using neighbor joining, but you may instead choose to estimate an initial species tree with something like IQTree, RAxML-NG, BEAST, or whatever software you prefer.","category":"page"},{"location":"guide/estgts/","page":"Using estimated gene trees and SNaQ","title":"Using estimated gene trees and SNaQ","text":"estgts = readMultiTopology(\"my-est-gts.treefile\")\n\n# Distance matrix\nD, namelist = calculateAGID(estgts)\n\n# Subset decomposition\nhybsubsets, treesubset = decomposeFromQuartets(\"quartets.dat\", cutoff=0.01)\n\n# Estimating constraint networks with SNaQ\nq, t = countquartetsintrees(estgts, showprogressbar=false)\nstartingtree = PhyloNetworks.nj!(deepcopy(D), deepcopy(namelist))\n\nconstraints = Array{HybridNetwork}(undef, length(hybsubsets))\nfor (j, hybsub) in enumerate(hybusbsets)\n    # Filter out all quartets that are not exclusively composed of taxa in `hybsub`\n    temptaxonnumbers = [i for i in 1:length(t) if t[i] in hybsub]\n    tempq = view(q, [i for i in 1:length(q) if all([number in temptaxonnumbers for number in q[i].taxonnumber])])\n    tempdf = readTableCF(writeTableCF(tempq, t))\n\n    # Estimate the network\n    constraints[j] = snaq!(startingtree, tempdf, hmax=Int64(ceil(length(hybsub) / 3)), runs=10)\nend\n\nmergednet = netnj(D, constraints; namelist=namelist)","category":"page"},{"location":"intro/accuracies/","page":"Accuracy evaluations","title":"Accuracy evaluations","text":"Accuracy evaluation","category":"page"},{"location":"intro/runtimes/","page":"Runtime evaluations","title":"Runtime evaluations","text":"Runtime evaluation","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"NetMerge.jl is a package for constructing phylogenetic super-networks in julia. Methods for estimating explicit phylogenetic networks like SNaQ and PhyNEST optimize over extremely large search spaces, leading to prohibitively long computation times for even as few as 20 taxa. With NetMerge, sub-networks are estimated on disjoint subsets of taxa and then merged via constrained neighbor joining. This allows accurate estimation of extremely large sets of taxa. For an in-depth discussion of the methods and results of NetMerge.jl, see this paper.","category":"page"},{"location":"documentation/#Most-relevant-functions","page":"Documentation","title":"Most relevant functions","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"netnj","category":"page"},{"location":"documentation/#NetMerge.netnj","page":"Documentation","title":"NetMerge.netnj","text":"netnj(D::Matrix{Float64}, constraints::Vector{HybridNetwork})\n\nCreates a super-network based on the constraint trees/networks in constraints and distance matrix D.\n\nArguments\n\nD: distance matrix relating pairs of taxa. This can be generated from estimated gene trees with calculateAGID\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"calculateAGID","category":"page"},{"location":"documentation/#NetMerge.calculateAGID","page":"Documentation","title":"NetMerge.calculateAGID","text":"calculateAGID(Ns::AbstractVector{HybridNetwork})\n\nCalculates the Average Gene tree Internode Distance for all pairs of taxa across all networks in Ns.\n\nReturns\n\nAGID matrix\nnames of taxa corresponding to rows/columns in the AGID matrix\n\n\n\n\n\n","category":"function"},{"location":"documentation/#All-documented-functions","page":"Documentation","title":"All documented functions","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Pages   = [\"documentation.md\"]","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Modules = [NetMerge]","category":"page"},{"location":"documentation/#NetMerge.TIEWARNING","page":"Documentation","title":"NetMerge.TIEWARNING","text":"findoptQ(D::Matrix{Float64}, idxpairs::Vector{Tuple{<:Integer, <:Integer}})\n\nFinds the minimizer (i, j) among all pairs (i, j) in idxpairs for Q, a matrix computed from D.\n\n\n\n\n\n","category":"constant"},{"location":"documentation/#NetMerge.Graph-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"NetMerge.Graph","text":"Converts the tree/network net into a SimpleGraph to leverage already implemented pathfinding algorithms.\n\nArguments\n\nincludeminoredges (default=true): if true, the entire network is translated to a graph.     Otherwise, only tree-like edges (other than those in alwaysinclude) are retained.\nalwaysinclude (default=nothing): edges that should always be included in the graph,     regardless of the value of includeminoredges\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.addrootedge!-Tuple{Graphs.SimpleGraphs.SimpleGraph, PhyloNetworks.HybridNetwork}","page":"Documentation","title":"NetMerge.addrootedge!","text":"Helper function that adds edges coming out from the root in net back into graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.calculateAGID-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"NetMerge.calculateAGID","text":"calculateAGID(Ns::AbstractVector{HybridNetwork})\n\nCalculates the Average Gene tree Internode Distance for all pairs of taxa across all networks in Ns.\n\nReturns\n\nAGID matrix\nnames of taxa corresponding to rows/columns in the AGID matrix\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.check_constraints-Tuple{Vector{PhyloNetworks.HybridNetwork}, Bool}","page":"Documentation","title":"NetMerge.check_constraints","text":"Checks validity of input constraints. So far, the only check is to make sure that all nodes have exactly 3 edges except for the root.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.check_ptable-Tuple{DataFrames.DataFrame}","page":"Documentation","title":"NetMerge.check_ptable","text":"Checks the input table to make sure that it is Holmes-Bonferroni adjusted. TODO: if it isn't, manually adjust it instead of throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.check_quartets-Tuple{Vector{Vector{String}}}","page":"Documentation","title":"NetMerge.check_quartets","text":"Makes sure the vector of abstract strings (that we call quartets) each have 4 unique entries.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.connectnodes!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"NetMerge.connectnodes!","text":"Deals with all the overhead of connecting two nodes with an edge. Returns the edge used to connect the nodes.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.decomposeFromQuartets-Tuple{AbstractString}","page":"Documentation","title":"NetMerge.decomposeFromQuartets","text":"Helper function that feeds into decomposeFromQuartets(namelist::ListOfNames, R::QuartetVector)\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.decomposeFromQuartets-Tuple{AbstractVector{<:AbstractString}, Vector{Vector{String}}}","page":"Documentation","title":"NetMerge.decomposeFromQuartets","text":"Decomposes the set of all taxa into disjoint subsets intelligently based on a roughly estimated species tree and significant quartets from MSCquartets.\n\nArguments\n\nT: the quickly estimated, rough species tree\nR: the set of statistically significant quartets, as obtained by MSCquartets\n\nReturn Value\n\nReturns a tuple. The first entry is list of subsets that are required in order to indentify all relevant reticulations. The second entry is the remaining taxa that aren't in the first entry.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.expandhybsubsetsD!-NTuple{5, Any}","page":"Documentation","title":"NetMerge.expandhybsubsetsD!","text":"expandhybsubsetsD!(hybsubs, other, quartets, D; maxlen::Int64=9)\n\nHelper function; hybsubs is the subset of taxa selected for hybridization identification, other is all other taxa which are currently unplaced. This function expands the taxa in other appropriately into various subsets in hybsubs based on distance matrix D.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.findsiblingpairs-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"NetMerge.findsiblingpairs","text":"findsiblingpairs(net::HybridNetwork)\n\nFinds sibling pairings for all the leaves in a single network. These pairs are valid for net but may not be valid when the     other constraint networks are also considered. Returns a vector of tuples of nodes corresponding to siblings.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.findvalidpairs-Tuple{Vector{PhyloNetworks.HybridNetwork}, AbstractVector{<:AbstractString}}","page":"Documentation","title":"NetMerge.findvalidpairs","text":"findvalidpairs(constraints::Vector{HybridNetwork}, namelist::AbstractVector{<:AbstractString})\n\nFinds all valid sibling pairs among the constraint networks.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.fuseredundantedges!-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"NetMerge.fuseredundantedges!","text":"Helper function to remove redundant edges (e.g. A –> (internal node) –> (internal node)) that arise from one case of the function mergeconstraintnodes!.\n\nRedundant nodes in this case will always have only two edges while not being the root.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.getsiblingcandidates-Tuple{PhyloNetworks.Node}","page":"Documentation","title":"NetMerge.getsiblingcandidates","text":"A helper function that finds other nodes in the net that leaf belongs to that may be its sibling. This function sees past reticulations, so that e.g. in ((A,(B,#H1)),((C)#H1,D)) B and C will be     marked as siblings.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.inany-Tuple{AbstractString, Vector{Vector{String}}}","page":"Documentation","title":"NetMerge.inany","text":"Helper function that finds whether name is listed in any subset in subsets\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.internodedistance-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"NetMerge.internodedistance","text":"internodedistance(N::HybridNetwork; namelist::Union{Nothing,<:AbstractVector{String}}=nothing)\n\nCalculates internode distances between all pairs of taxa in network N.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.kconnected-Tuple{AbstractVector{<:AbstractString}, Vector{<:AbstractString}, Vector{Vector{String}}}","page":"Documentation","title":"NetMerge.kconnected","text":"Takes minsubset, a subset defined in the function minimumuniquesubset, and, for each entry i of minsubset, gathers the k-1 taxa that i appears with most often across all quartets.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.majorinternodedistance-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"NetMerge.majorinternodedistance","text":"majorinternodedistance(N::HybridNetwork)\n\nCalculates internode distances between all pairs of taxa in the major displayed tree of network N. If N is a tree, then internode distances are as expected for a tree.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.mergesubnets!-Tuple{SubNet, SubNet}","page":"Documentation","title":"NetMerge.mergesubnets!","text":"Merges two unrooted SubNets into a single unrooted SubNet Returns the merged subnet AND the edges in the merged net     corresponding to where reticulations will be placed if there     are corresponding reticulations discovered in the constraints.\n\nIMPORTANT: this function should NOT make copies of edges or     nodes, object references are stored and used in     the main merging algorithm\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.minimumuniquesubset-Tuple{AbstractVector{<:AbstractString}, Vector{Vector{String}}}","page":"Documentation","title":"NetMerge.minimumuniquesubset","text":"Finds the smallest subset S of names in namelist such that every quartet in R has at least one of its taxa in S.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.netnj-Tuple{Matrix{Float64}, Vector{PhyloNetworks.HybridNetwork}, AbstractVector{<:AbstractString}}","page":"Documentation","title":"NetMerge.netnj","text":"netnj(D::Matrix{Float64}, constraints::Vector{HybridNetwork})\n\nCreates a super-network based on the constraint trees/networks in constraints and distance matrix D.\n\nArguments\n\nD: distance matrix relating pairs of taxa. This can be generated from estimated gene trees with calculateAGID\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.parsequartets-Tuple{AbstractString}","page":"Documentation","title":"NetMerge.parsequartets","text":"Reads output from MSCquartets in R and parses it so that it can be used efficiently with our julia code.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.parsequartets-Tuple{DataFrames.DataFrame}","page":"Documentation","title":"NetMerge.parsequartets","text":"Reads output from MSCquartets in R and parses it so that it can be used efficiently with our julia code.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.placeretics!-Tuple{PhyloNetworks.HybridNetwork, ReticMap}","page":"Documentation","title":"NetMerge.placeretics!","text":"Updates net to include the reticulations that we've kept track of along the way in our algo but haven't placed yet.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.removeredundantedges!-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Documentation","title":"NetMerge.removeredundantedges!","text":"Helper function that removes redundant edges in the graph that exist when some hybrids are pruned from the graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.requiredhybridsubsets-Tuple{AbstractVector{<:AbstractString}, Vector{Vector{String}}}","page":"Documentation","title":"NetMerge.requiredhybridsubsets","text":"Current base subset decomposition schema. First, we find the smallest subset S of names such that all quartets have at least one taxa in the subset. Then, for each entry of S, we gather the set of 3 other taxa it appears with most often in the quartets in R.\n\nThe idea behind these subsets is to guarantee identifiability of hybridizations, hence why they are required.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.updateconstraints!-Tuple{AbstractString, AbstractString, Vector{PhyloNetworks.HybridNetwork}, ReticMap, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Documentation","title":"NetMerge.updateconstraints!","text":"Updates constraint networks after (i, j) with names (nodenamei, nodenamej) have been merged. Also updates reticmap to keep track of any reticulations that get removed in this process.\n\nBy convention we keep nodenamei and replace node names with nodenamej\n\n\n\n\n\n","category":"method"},{"location":"documentation/#NetMerge.vecreplace!-Union{Tuple{T}, Tuple{Vector{T}, T, T}} where T","page":"Documentation","title":"NetMerge.vecreplace!","text":"Helper function for manipulating graph adjacency lists.\n\n\n\n\n\n","category":"method"}]
}
