var documenterSearchIndex = {"docs":
[{"location":"walkthrough/d-matrix/#Estimating-a-pairwise-distance-matrix","page":"Estimate a pairwise distance matrix","title":"Estimating a pairwise distance matrix","text":"","category":"section"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"Two methods for estimating pairwise distance matrices are implemented in InPhyNet.jl: calculateAGID and calculateAGIC. These correspond to Average Gene-tree Internode Distance/Count. The former (distance) averages the distance by branch length between each pair of taxa across all gene trees, while the latter (count) averages the number of internal nodes in each gene tree separate each pair of taxa across all gene trees.","category":"page"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"For example, the internode distance between taxa A and C below is 4, while the internode count between them is 2 (the root is not counted).","category":"page"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"(Image: Example gene tree)","category":"page"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"For this walkthrough, we will use the AGID metric:","category":"page"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"using InPhyNet, PhyloNetworks, SNaQ\n\nest_gts = load_inphynet_example_gts();\nD, namelist = calculateAGID(est_gts);","category":"page"},{"location":"walkthrough/full_net/#Constructing-the-full-network","page":"Constructing the full network","title":"Constructing the full network","text":"","category":"section"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"Finally, putting the full network together with InPhyNet is simple:","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"species_net = inphynet(D, snaq_networks, namelist)","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"Our example has an outgroup taxa, so we can root the network at that outgroup.","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"rootatnode!(species_net, \"OUTGROUP\")","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"Now, we can use PhyloPlots.jl to plot the species network.","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"using PhyloPlots\nplot(species_net);","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"(Image: Full network)","category":"page"},{"location":"intro/accuracies/","page":"-","title":"-","text":"Accuracy evaluation","category":"page"},{"location":"walkthrough/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"This walkthrough will take you through the steps of generating each piece of data needed to run InPhyNet to infer a 50 taxa network rapidly and accurately. Data used at each step of this walkthrough is available via functions that are built-in to InPhyNet.jl, so feel free to follow along or use your own data instead!","category":"page"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"walkthrough/introduction/#Requirements:","page":"Introduction","title":"Requirements:","text":"","category":"section"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"Julia installed\nInPhyNet and SNaQ Julia packages installed","category":"page"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"walkthrough/introduction/#Steps:","page":"Introduction","title":"Steps:","text":"","category":"section"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"|| Step | Input | Output | |-|–––|–––-|––––| | 1 | Estimate a pairwise distance matrix | Input data I^* | Matrix D | | 2 | Separate your taxa into subsets | D | Subsets mathbfS=S_i_i=1^k | | 3 | Infer \"constraint\" networks on your subsets of taxa | ImathbfS | Networks mathbfN=N_i_i=1^k | | 4 | Put it together with InPhyNet | DmathbfN | Species network mathcalN |","category":"page"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"^*I","category":"page"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"can be any form of input data with which a distance matrix and semi-directed networks can be computed and inferred. Here, we utilize estimated gene trees.","category":"page"},{"location":"intro/runtimes/","page":"-","title":"-","text":"Runtime evaluation","category":"page"},{"location":"installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia is a high-level interactive programming language with C-like runtime speeds. To download and install Julia, following the instructions here. For a quick introduction to Julia, see this article from Learn X in Y minutes.","category":"page"},{"location":"installation/#Install-InPhyNet","page":"Installation","title":"Install InPhyNet","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install InPhyNet, simply open an interactive Julia session and type the following:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"https://github.com/NathanKolbow/InPhyNet.jl\")","category":"page"},{"location":"walkthrough/subsets/#Choosing-your-subsets","page":"Choosing your subsets","title":"Choosing your subsets","text":"","category":"section"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"For thorough analyses, careful subset selection is important. InPhyNet cannot infer instances of reticulate evolution between its input networks, so several taxa from clades where reticulate evolution is likely to have occurred should appear together in at least one subset. To this end, we recommend first performing analyses with software like TINNiK to identify these areas. We provide an example of how this could be done below.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"Here, we take a naive approach and simply perform centroid edge decomposition on a species tree inferred by InPhyNet without any constraint networks (this is equivalent to Neighbor-Joining). Centroid edge decomposition is a recursive process that splits a \"guide tree\" in half at a single edge such that the two halves are of equal size. Then, this process is done recursively on the resulting trees until each subtree contains at most some predefined number of taxa.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"This requires us to specify a maximum subset size–for this walkthrough we will use 8. In practice we recommend that you use the highest number such that you can still infer networks in a reasonable amount of time with your preferred network inference software. We use 8 here so that all of the walkthrough can be completed quickly.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"Additionally, we specify a minimum subset size of 5 because that is the smallest set of data that SNaQ can infer a network on.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"nj_tre = inphynet(D, namelist)\nsubsets = centroid_edge_decomposition(nj_tre, 5, 8)","category":"page"},{"location":"walkthrough/subsets/#Using-TINNiK","page":"Choosing your subsets","title":"Using TINNiK","text":"","category":"section"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"TINNiK is implemented in the MSCquartets package in R, so we need to save our estimated gene trees to a file so that they can be opened in R.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"# In Julia\nwritemultinewick(est_gts, \"example_gts.tre\")","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"The runtime of TINNIK quickly climbs with the number of taxa being evaluated. With our 51 taxa example it may take several minutes for results to come back. In the case of many more taxa it could take several hours, days, or even longer. In such cases, TINNIK may not be the preferred tool for conducting this portion of the analyses. If it is still preferred, though, it may be necessary to break the set of all taxa into smaller subsets each of which has its own tree of blobs inferred.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"# In R\nlibrary(MSCquartets)\n\ngts <- read.tree(file = \"example_gts.tre\")\nresults <- TINNIK(gts, alpha=0.05, beta=0.95, plot=FALSE)\ntob <- results$ToB\n\nplot(tob)","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"(Image: First Tree of Blobs)","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"When using TINNIK, it is important to explore multiple values of alpha and beta before assessing any results. Fortunately, evaluating subsequent values for alpha and beta is very fast because we can re-use data from the original analysis.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"[!NOTE]","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"More information on alpha and beta parameters, including best practices recommended by the authors of TINNIK, can be found in this TINNIK vignette, which we highly recommend reading before using TINNIK.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"results2 <- TINNIK(results$pTable, alpha=0.01, beta=0.99, plot=FALSE)\ntob2 <- results2$ToB\n\nplot(tob2)","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"(Image: Second Tree of Blobs)","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"From these results, we would ideally split these taxa three subsets:","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"Containing the taxa with tree-like relationships at the top of the figure along with the outgroup\nThe first large block of taxa represented by a multifurcation (t48, t46, t45, ..., t30, t26)\nThe second such large block of taxa (t4, t23, t22, ..., t17, t16, t1)","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"For this walkthrough, such subsets would lead to very long inference times, so we will forgo this step and instead utilize the subsets generated above.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"[!NOTE]","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"In practice, if such subsets are too large to be feasible with your preferred method of network inference, then concessions must be made in some manner, likely either by splitting these blocks into smaller subsets or by utilizing a faster but less accurate method of network inference.","category":"page"},{"location":"walkthrough/constraints/#Inferring-constraint-networks","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"","category":"section"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"Constraint networks can be inferred with any method of your choosing, such as SNaQ, PhyNEST, PhyloNet, or NANUQ (implemented in the MSCquartets R package). We utilize SNaQ because it is also implemented in Julia, so the workflow can all be contained in a single, straight-forward script.","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"For each subset, we need to perform the following in order to infer a network with SNaQ:","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"Prune the estimated gene trees to only include taxa in the subset\nGenerate SNaQ's input data\nRun SNaQ","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"[!NOTE]","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"When using SNaQ, it is best practice to (1) set the runs parameter to a large value (at least 10) and (2) infer networks with numbers of hybrids h=0123 before performing model selection to determine the \"best\" network. For simplicity, here we only perform 1 run for each inferred network and we only infer networks with h=1.","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"# First, make a folder to put the data in\nisdir(\"snaq_data\") || mkdir(\"snaq_data\")\n\n# We will store the inferred networks in this array\nsnaq_networks = Array{HybridNetwork}(undef, length(subsets))\n\nfor (i, subset) in enumerate(subsets)\n    @info \"Inferring network for subset $(i)/$(length(subsets))\"\n\n    # 1. Prune estimated gene trees\n    subset_gts = prune_networks(est_gts, subset)\n\n    # 2. Generate SNaQ's input data\n    df = readtrees2CF(subset_gts, writeTab=false, writeSummary=false)\n\n    # 3. Run SNaQ\n    snaq_networks[i] = snaq!(subset_gts[1], df, hmax=1, filename=\"snaq_data/snaq_subset$(i)\", runs=1, seed=42)\nend","category":"page"},{"location":"#InPhyNet","page":"Home","title":"InPhyNet","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InPhyNet is a Julia package for constructing large phylogenetic networks from a set of smaller, disjoint networks.","category":"page"},{"location":"#Why-use-InPhyNet?","page":"Home","title":"Why use InPhyNet?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InPhyNet enables the inference of large-scale phylogenetic networks that would otherwise be computationally infeasible to infer with methods like SNaQ, PhyNEST, or PhyloNet. Additionally, the InPhyNet.jl Julia package is easy to install and run if you already have estimated gene trees or several small phylogenetic networks that you want to merge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!–","category":"page"},{"location":"#How-does-InPhyNet-work?","page":"Home","title":"How does InPhyNet work?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InPhyNet is a heuristics-based method that constructs a species network using a distance matrix D and a set of constraint networks mathbfN. –>","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pending BibTeX citation","category":"page"},{"location":"documentation/#Most-relevant-functions","page":"Documentation","title":"Most relevant functions","text":"","category":"section"},{"location":"documentation/#InPhyNet.inphynet","page":"Documentation","title":"InPhyNet.inphynet","text":"Runs the InPhyNet algorithm on the given distance matrix and constraint networks where the entries in namelist correspond to indices in D.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#InPhyNet.calculateAGID","page":"Documentation","title":"InPhyNet.calculateAGID","text":"calculateAGID(Ns::AbstractVector{HybridNetwork})\n\nCalculates the Average Gene tree Internode Distance for all pairs of taxa across all networks in Ns.\n\nReturns\n\nAGID matrix\nnames of taxa corresponding to rows/columns in the AGID matrix\n\n\n\n\n\n","category":"function"},{"location":"documentation/#All-documented-functions","page":"Documentation","title":"All documented functions","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Pages   = [\"documentation.md\"]","category":"page"},{"location":"documentation/#InPhyNet.Graph-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.Graph","text":"Converts the tree/network net into a SimpleGraph to leverage already implemented pathfinding algorithms.\n\nArguments\n\nincludeminoredges (default=true): if true, the entire network is translated to a graph.     Otherwise, only tree-like edges (other than those in alwaysinclude) are retained.\nalwaysinclude (default=nothing): edges that should always be included in the graph,     regardless of the value of includeminoredges\nwithweights (default=false): return a set of weights corresponding to branch lengths as well\nremoveredundantedgecost (default=false): if true, finds all the nodes that would be removed via     removeredundantedges! and sets their weights in W to 0\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.are_compatible_after_merge-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}, AbstractString, AbstractString}","page":"Documentation","title":"InPhyNet.are_compatible_after_merge","text":"Heuristic for determining whether the set of networks ns are compatible.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.calculateAGIC-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.calculateAGIC","text":"calculateAGIC(Ns::AbstractVector{HybridNetwork})\n\nCalculates the Average Gene tree Internode Counts for all pairs of taxa across all networks in Ns. If allow_missing_pairs is false, an error will be thrown if there are pairs of taxa that never appear in Ns together. Otherwise, entries for taxa that never appear together will be set to default_missing_value.\n\nReturns\n\nAGIC matrix\nnames of taxa corresponding to rows/columns in the AGID matrix\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.calculateAGID-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.calculateAGID","text":"calculateAGID(Ns::AbstractVector{HybridNetwork})\n\nCalculates the Average Gene tree Internode Distance for all pairs of taxa across all networks in Ns.\n\nReturns\n\nAGID matrix\nnames of taxa corresponding to rows/columns in the AGID matrix\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.calculate_average_network_metric-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}, Function}","page":"Documentation","title":"InPhyNet.calculate_average_network_metric","text":"Calculates pairwise_metric on each pair of networks in Ns. Called by calculateAGIC and calculateAGID. pairwise_metric must be a function that takes a HybridNetwork as its first positional input, must accept     the named argument namelist, and must return a 2-Tuple of (A, B), where A is the pairwise metric     applied to all pairs of taxa in the supplied network, and B is the namelist used or generated by the fxn.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.centroid_edge_decomposition-Tuple{PhyloNetworks.HybridNetwork, Integer, Integer}","page":"Documentation","title":"InPhyNet.centroid_edge_decomposition","text":"Slightly adjusted implementation of the decomposition algorithm from SATe-I that takes a maximum and a minimum subset size.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.check_constraint!","page":"Documentation","title":"InPhyNet.check_constraint!","text":"Checks validity of a single input constraint networks. Checks include:\n\nAll nodes have exactly 3 edges except the root (unless the network is a single taxa)\nReticulations do not lead directly into other reticulations\n\n\n\n\n\n","category":"function"},{"location":"documentation/#InPhyNet.check_constraints!-Tuple{Vector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.check_constraints!","text":"Checks validity of input constraints. So far, the only check is to make sure that all nodes have exactly 3 edges except for the root.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.connectnodes!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.connectnodes!","text":"Deals with all the overhead of connecting two nodes with an edge. Returns the edge used to connect the nodes.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.find_not_in_path_edge_vector-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Array{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.find_not_in_path_edge_vector","text":"Helper function for when an edge (notinpath_edge) appears on but not within a merge path. Finds and returns:     1. Whether the edge should be logged with direction \"to\" or \"from\"     2. Whether the edge should be associated with subnetedgei or subnetedgej\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.find_valid_node_path-Tuple{PhyloNetworks.HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.find_valid_node_path","text":"Helper function that finds a path in net from nodei to nodej. If that path has 2 or more reticulations in it, the cost to include a hybrid in the path is incrementally increased until only 1 reticulation is in the path.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.findoptQidx-Tuple{AbstractMatrix{Float64}, BitArray, AbstractVector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.findoptQidx","text":"findoptQ(D::Matrix{Float64}, idxpairs::Vector{Tuple{<:Integer, <:Integer}})\n\nFinds the minimizer (i, j) among all pairs (i, j) in idxpairs for Q, a matrix computed from D.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.findsiblingpairs-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.findsiblingpairs","text":"findsiblingpairs(net::HybridNetwork)\n\nFinds sibling pairings for all the leaves in a single network. These pairs are valid for net but may not be valid when the     other constraint networks are also considered. Returns a vector of tuples of nodes corresponding to siblings.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.findvalidpairs-Tuple{Vector{PhyloNetworks.HybridNetwork}, Any, AbstractVector{<:AbstractString}}","page":"Documentation","title":"InPhyNet.findvalidpairs","text":"findvalidpairs(constraints::Vector{HybridNetwork}, constraint_sibling_pairs, namelist::AbstractVector{<:AbstractString})\n\nFinds all valid sibling pairs among the constraint networks.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.fuseredundantedges!-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.fuseredundantedges!","text":"Helper function to remove redundant edges (e.g. A –> (internal node) –> (internal node)) that arise from one case of the function mergeconstraintnodes!.\n\nRedundant nodes in this case will always have only two edges while not being the root.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.gather_hyb_descendants_outside_of_path-Tuple{PhyloNetworks.Node, Array{PhyloNetworks.Node}}","page":"Documentation","title":"InPhyNet.gather_hyb_descendants_outside_of_path","text":"Helper function used at one point in mergeconstraintnodes!. Gets all of the descendants of node that do not have any children and are not in path\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.getLeavesUnderEdge-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Documentation","title":"InPhyNet.getLeavesUnderEdge","text":"Gets all the leaf nodes underneath edge edge.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.getMidSplitEdge-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.getMidSplitEdge","text":"Finds a branch in tre that, when pruned on, splits the tree roughly in half.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.has_direct_root_connection-Tuple{PhyloNetworks.HybridNetwork, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.has_direct_root_connection","text":"Helper function - returns true if the node node is connected directly to the root of net, or if the path connecting node to net's root is multiple redundant edges (e.g. returns true for A in the net: \"((((((A))))), (B,C));\")\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.inphynet-2","page":"Documentation","title":"InPhyNet.inphynet","text":"Runs the InPhyNet algorithm on the given distance matrix and constraint networks where the entries in namelist correspond to indices in D.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#InPhyNet.internodecount-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.internodecount","text":"internodecount(N::HybridNetwork; namelist::Union{Nothing,<:AbstractVector{String}}=nothing)\n\nCalculates internode counts between all pairs of taxa in network N. WARNING: treats N as unrooted\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.internodedistance-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.internodedistance","text":"internodedistance(N::HybridNetwork; namelist::Union{Nothing,<:AbstractVector{String}}=nothing)\n\nCalculates internode distance between all pairs of taxa in network N.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.log_edge_path_retics_from_node-Tuple{PhyloNetworks.Node, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Bool, Bool, Union{Nothing, PhyloNetworks.EdgeT{PhyloNetworks.Node}}, InPhyNet.ReticMap, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.HybridNetwork, Bool, AbstractVector{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.log_edge_path_retics_from_node","text":"Helper function\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.major_mrca-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.major_mrca","text":"Gets the MRCA of nodei and nodej along their major tree.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.majorinternodecount-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.majorinternodecount","text":"majorinternodecount(N::HybridNetwork)\n\nCalculates major internode counts between all pairs of taxa in the major displayed tree of network N. If N is a tree, then internode counts are as expected for a tree.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.majorinternodedistance-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.majorinternodedistance","text":"majorinternodedistance(N::HybridNetwork)\n\nCalculates internode distances between all pairs of taxa in the major displayed tree of network N. If N is a tree, then internode distances are as expected for a tree.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.mergesubnets!-Tuple{InPhyNet.SubNet, InPhyNet.SubNet}","page":"Documentation","title":"InPhyNet.mergesubnets!","text":"Merges two unrooted SubNets into a single unrooted SubNet Returns the merged subnet AND the edges in the merged net     corresponding to where reticulations will be placed if there     are corresponding reticulations discovered in the constraints.\n\nIMPORTANT: this function should NOT make copies of edges or     nodes, object references are stored and used in     the main merging algorithm\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.placeretics!-Tuple{PhyloNetworks.HybridNetwork, InPhyNet.ReticMap, Any}","page":"Documentation","title":"InPhyNet.placeretics!","text":"Updates net to include the reticulations that we've kept track of along the way in our algo but haven't placed yet.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.prune_network-Tuple{PhyloNetworks.HybridNetwork, AbstractVector{<:AbstractVector{<:AbstractString}}}","page":"Documentation","title":"InPhyNet.prune_network","text":"Returns a list of networks where each entry is a copy of net pruned to include only the taxa named in each subset contained in subsets. subsets can also be an individual vector of strings instead of a nested vector (see examples below).\n\nExample\n\nnet = readnewick(\"((t1,t2),(t3,t4));\")\nprune_network(net, [[\"t1\", \"t2\"], [\"t3\", \"t4\"]])\n> 2-element Vector{HybridNetwork}: (t1, t2); and (t3, t4);\n\nprune_network(net, [\"t1\", \"t2\", \"t3\"])\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.removeredundantedges!-Tuple{Graphs.SimpleGraphs.SimpleGraph, PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.removeredundantedges!","text":"Helper function that removes redundant edges in the graph that exist when some hybrids are pruned from the graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.root_constraints!-Tuple{Vector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.root_constraints!","text":"If any constraints are unrooted, picks a root node from any node directly under the root (somewhat randomly).\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.sateIdecomp-Tuple{PhyloNetworks.HybridNetwork, Integer}","page":"Documentation","title":"InPhyNet.sateIdecomp","text":"Performs subset decomposition as outlines in SATe-I on inittree. Returns vector of vector of names, e.g. [[\"a\", \"b\"], [\"c\", \"d\", \"e\"]]\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.splitAtEdge-Tuple{PhyloNetworks.HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Documentation","title":"InPhyNet.splitAtEdge","text":"Splits tre into two trees at its longest branch.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.updateconstraints!-Tuple{AbstractString, AbstractString, Vector{PhyloNetworks.HybridNetwork}, InPhyNet.ReticMap, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Documentation","title":"InPhyNet.updateconstraints!","text":"Updates constraint networks after (i, j) with names (nodenamei, nodenamej) have been merged. Also updates reticmap to keep track of any reticulations that get removed in this process.\n\nBy convention we keep nodenamei and replace node names with nodenamej\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.vecreplace!-Union{Tuple{T}, Tuple{Vector{T}, T, T}} where T","page":"Documentation","title":"InPhyNet.vecreplace!","text":"Helper function for manipulating graph adjacency lists.\n\n\n\n\n\n","category":"method"}]
}
