var documenterSearchIndex = {"docs":
[{"location":"walkthrough/d-matrix/#Estimating-a-pairwise-distance-matrix","page":"Estimate a pairwise distance matrix","title":"Estimating a pairwise distance matrix","text":"","category":"section"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"Two methods for estimating pairwise distance matrices are implemented in InPhyNet.jl: calculateAGID and calculateAGIC. These correspond to Average Gene-tree Internode Distance/Count. The former (distance) averages the distance by branch length between each pair of taxa across all gene trees, while the latter (count) averages the number of internal nodes in each gene tree separate each pair of taxa across all gene trees.","category":"page"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"For example, the internode distance between taxa A and C below is 4, while the internode count between them is 2 (the root is not counted).","category":"page"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"(Image: Example gene tree)","category":"page"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"For this walkthrough, we will use the AGID metric:","category":"page"},{"location":"walkthrough/d-matrix/","page":"Estimate a pairwise distance matrix","title":"Estimate a pairwise distance matrix","text":"using InPhyNet, PhyloNetworks, SNaQ\n\nest_gts = load_inphynet_example_gts()\nD, namelist = calculateAGID(est_gts);","category":"page"},{"location":"walkthrough/full_net/#Constructing-the-full-network","page":"Constructing the full network","title":"Constructing the full network","text":"","category":"section"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"Finally, putting the full network together with InPhyNet is simple:","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"species_net = inphynet(D, snaq_networks, namelist)","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"Our example has an outgroup taxa, so we can root the network at that outgroup to obtain the network shown below:","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"rootatnode!(species_net, \"OUTGROUP\")","category":"page"},{"location":"walkthrough/full_net/","page":"Constructing the full network","title":"Constructing the full network","text":"(Image: Full network)","category":"page"},{"location":"intro/accuracies/","page":"-","title":"-","text":"Accuracy evaluation","category":"page"},{"location":"walkthrough/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"This walkthrough will take you through the steps of generating each piece of data needed to run InPhyNet to infer a 50 taxa network rapidly and accurately. Data used at each step of this walkthrough is available via functions that are built-in to InPhyNet.jl, so feel free to follow along or use your own data instead!","category":"page"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"walkthrough/introduction/#Requirements:","page":"Introduction","title":"Requirements:","text":"","category":"section"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"Julia installed\nInPhyNet and SNaQ Julia packages installed","category":"page"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"walkthrough/introduction/#Steps:","page":"Introduction","title":"Steps:","text":"","category":"section"},{"location":"walkthrough/introduction/","page":"Introduction","title":"Introduction","text":"Estimate a pairwise distance matrix\nSeparate your taxa into subsets\nInfer \"constraint\" networks on your subsets of taxa\nPut it together with InPhyNet","category":"page"},{"location":"intro/runtimes/","page":"-","title":"-","text":"Runtime evaluation","category":"page"},{"location":"installation/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia is a high-level interactive programming language with C-like runtime speeds. To download and install Julia, following the instructions here. For a quick introduction to Julia, see this article from Learn X in Y minutes.","category":"page"},{"location":"installation/#Install-InPhyNet","page":"Installation","title":"Install InPhyNet","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install InPhyNet, simply open an interactive Julia session and type the following:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"https://github.com/NathanKolbow/InPhyNet.jl\")","category":"page"},{"location":"walkthrough/subsets/#Choosing-your-subsets","page":"Choosing your subsets","title":"Choosing your subsets","text":"","category":"section"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"For thorough analyses, careful subset selection is important. InPhyNet cannot infer instances of reticulate evolution between its input networks, so several taxa from clades where reticulate evolution is likely to have occurred should appear together in at least one subset. To this end, we recommend first performing analyses with software like TINNiK to identify these areas.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"Here, we take a naive approach and simply perform centroid edge decomposition on a species tree inferred by InPhyNet without any constraint networks (this is equivalent to Neighbor-Joining). This requires us to specify a maximum subset sizeâ€“for this walkthrough we will use 8. In practice we recommend that you use the highest number such that you can still infer networks in a reasonable amount of time with your preferred network inference software. We use 8 here so that all of the walkthrough can be completed quickly.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"Additionally, we specify a minimum subset size of 5 because that is the smallest set of data that SNaQ can infer a network on.","category":"page"},{"location":"walkthrough/subsets/","page":"Choosing your subsets","title":"Choosing your subsets","text":"nj_tre = inphynet(D, namelist)\nsubsets = centroid_edge_decomposition(nj_tre, 5, 8)","category":"page"},{"location":"walkthrough/constraints/#Inferring-constraint-networks","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"","category":"section"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"We infer constraint networks here with SNaQ, but any applicable method can be used, including PhyNEST, PhyloNet, or NANUQ (implemented in the MSCquartets R package).","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"For each subset, we need to perform the following in order to infer a network with SNaQ:","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"Prune the estimated gene trees to only include taxa in the subset\nGenerate SNaQ's input data\nRun SNaQ","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"When using SNaQ, it is best practice to (1) perform many runs for each inferred network (typically 10) and (2) infer networks with numbers of hybrids h=0123 before performing model selection to determine the \"best\" network. For simplicity, here we only perform 2 runs for each inferred network and we only infer networks with h=1.","category":"page"},{"location":"walkthrough/constraints/","page":"Inferring constraint networks","title":"Inferring constraint networks","text":"# First, make a folder to put the data in\nisdir(\"snaq_data\") || mkdir(\"snaq_data\")\n\n# We will store the inferred networks in this array\nsnaq_networks = Array{HybridNetwork}(undef, length(subsets))\n\nfor (i, subset) in enumerate(subsets)\n    @info \"Inferring network for subset $(i)/$(length(subsets))\"\n\n    # 1. Prune estimated gene trees\n    subset_gts = prune_networks(est_gts, subset)\n\n    # 2. Generate SNaQ's input data\n    df = readtrees2CF(subset_gts, writeTab=false, writeSummary=false)\n\n    # 3. Run SNaQ\n    snaq_networks[i] = snaq!(subset_gts[1], df, hmax=1, filename=\"snaq_data/snaq_subset$(i)\", runs=1, seed=42)\nend","category":"page"},{"location":"#InPhyNet","page":"Home","title":"InPhyNet","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InPhyNet is a Julia package for constructing large phylogenetic networks from a set of smaller, disjoint networks.","category":"page"},{"location":"#Why-use-InPhyNet?","page":"Home","title":"Why use InPhyNet?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"InPhyNet enables the inference of large-scale phylogenetic networks that would otherwise be computationally infeasible to infer with methods like SNaQ, PhyNEST, or PhyloNet. Additionally, the InPhyNet.jl Julia package is easy to install and run if you already have estimated gene trees or several small phylogenetic networks that you want to merge.","category":"page"},{"location":"documentation/#Most-relevant-functions","page":"Documentation","title":"Most relevant functions","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"inphynet","category":"page"},{"location":"documentation/#InPhyNet.inphynet","page":"Documentation","title":"InPhyNet.inphynet","text":"Runs the InPhyNet algorithm on the given distance matrix and constraint networks where the entries in namelist correspond to indices in D.\n\n\n\n\n\n","category":"function"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"calculateAGID","category":"page"},{"location":"documentation/#InPhyNet.calculateAGID","page":"Documentation","title":"InPhyNet.calculateAGID","text":"calculateAGID(Ns::AbstractVector{HybridNetwork})\n\nCalculates the Average Gene tree Internode Distance for all pairs of taxa across all networks in Ns.\n\nReturns\n\nAGID matrix\nnames of taxa corresponding to rows/columns in the AGID matrix\n\n\n\n\n\n","category":"function"},{"location":"documentation/#All-documented-functions","page":"Documentation","title":"All documented functions","text":"","category":"section"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Pages   = [\"documentation.md\"]","category":"page"},{"location":"documentation/","page":"Documentation","title":"Documentation","text":"Modules = [InPhyNet]","category":"page"},{"location":"documentation/#InPhyNet.Graph-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.Graph","text":"Converts the tree/network net into a SimpleGraph to leverage already implemented pathfinding algorithms.\n\nArguments\n\nincludeminoredges (default=true): if true, the entire network is translated to a graph.     Otherwise, only tree-like edges (other than those in alwaysinclude) are retained.\nalwaysinclude (default=nothing): edges that should always be included in the graph,     regardless of the value of includeminoredges\nwithweights (default=false): return a set of weights corresponding to branch lengths as well\nremoveredundantedgecost (default=false): if true, finds all the nodes that would be removed via     removeredundantedges! and sets their weights in W to 0\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.addrootedge!-Tuple{Graphs.SimpleGraphs.SimpleGraph, PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.addrootedge!","text":"Helper function that adds edges coming out from the root in net back into graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.are_compatible_heuristic-Tuple{AbstractVector{<:PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.are_compatible_heuristic","text":"Heuristic for determining whether the set of networks ns are compatible.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.are_compatible_heuristic-Tuple{PhyloNetworks.HybridNetwork, PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.are_compatible_heuristic","text":"Heuristic for determining whether trees t1 and t2 are compatible. In the case of networks, t1 and t2 are the major trees of some other networks.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.calculateAGIC-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.calculateAGIC","text":"calculateAGIC(Ns::AbstractVector{HybridNetwork})\n\nCalculates the Average Gene tree Internode Counts for all pairs of taxa across all networks in Ns. If allow_missing_pairs is false, an error will be thrown if there are pairs of taxa that never appear in Ns together. Otherwise, entries for taxa that never appear together will be set to default_missing_value.\n\nReturns\n\nAGIC matrix\nnames of taxa corresponding to rows/columns in the AGID matrix\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.calculateAGID-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.calculateAGID","text":"calculateAGID(Ns::AbstractVector{HybridNetwork})\n\nCalculates the Average Gene tree Internode Distance for all pairs of taxa across all networks in Ns.\n\nReturns\n\nAGID matrix\nnames of taxa corresponding to rows/columns in the AGID matrix\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.calculate_average_network_metric-Tuple{AbstractVector{PhyloNetworks.HybridNetwork}, Function}","page":"Documentation","title":"InPhyNet.calculate_average_network_metric","text":"Calculates pairwise_metric on each pair of networks in Ns. Called by calculateAGIC and calculateAGID. pairwise_metric must be a function that takes a HybridNetwork as its first positional input, must accept     the named argument namelist, and must return a 2-Tuple of (A, B), where A is the pairwise metric     applied to all pairs of taxa in the supplied network, and B is the namelist used or generated by the fxn.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.check_constraint!","page":"Documentation","title":"InPhyNet.check_constraint!","text":"Checks validity of a single input constraint networks. Checks include:\n\nAll nodes have exactly 3 edges except the root (unless the network is a single taxa)\nReticulations do not lead directly into other reticulations\n\n\n\n\n\n","category":"function"},{"location":"documentation/#InPhyNet.check_constraints!-Tuple{Vector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.check_constraints!","text":"Checks validity of input constraints. So far, the only check is to make sure that all nodes have exactly 3 edges except for the root.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.check_ptable-Tuple{DataFrames.DataFrame}","page":"Documentation","title":"InPhyNet.check_ptable","text":"Checks the input table to make sure that it is Holmes-Bonferroni adjusted. TODO: if it isn't, manually adjust it instead of throwing an error.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.check_quartets-Tuple{Vector{Vector{String}}}","page":"Documentation","title":"InPhyNet.check_quartets","text":"Makes sure the vector of abstract strings (that we call quartets) each have 4 unique entries.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.connectnodes!-Tuple{PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.connectnodes!","text":"Deals with all the overhead of connecting two nodes with an edge. Returns the edge used to connect the nodes.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.decomposeFromQuartets-Tuple{AbstractString}","page":"Documentation","title":"InPhyNet.decomposeFromQuartets","text":"Helper function that feeds into decomposeFromQuartets(namelist::ListOfNames, R::QuartetVector)\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.decomposeFromQuartets-Tuple{AbstractVector{<:AbstractString}, Vector{Vector{String}}}","page":"Documentation","title":"InPhyNet.decomposeFromQuartets","text":"Decomposes the set of all taxa into disjoint subsets intelligently based on a roughly estimated species tree and significant quartets from MSCquartets.\n\nArguments\n\nT: the quickly estimated, rough species tree\nR: the set of statistically significant quartets, as obtained by MSCquartets\n\nReturn Value\n\nReturns a tuple. The first entry is list of subsets that are required in order to indentify all relevant reticulations. The second entry is the remaining taxa that aren't in the first entry.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.expandhybsubsetsD!-NTuple{5, Any}","page":"Documentation","title":"InPhyNet.expandhybsubsetsD!","text":"expandhybsubsetsD!(hybsubs, other, quartets, D; maxlen::Int64=9)\n\nHelper function; hybsubs is the subset of taxa selected for hybridization identification, other is all other taxa which are currently unplaced. This function expands the taxa in other appropriately into various subsets in hybsubs based on distance matrix D.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.find_not_in_path_edge_vector-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, Array{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.find_not_in_path_edge_vector","text":"Helper function for when an edge (notinpath_edge) appears on but not within a merge path. Finds and returns:     1. Whether the edge should be logged with direction \"to\" or \"from\"     2. Whether the edge should be associated with subnetedgei or subnetedgej\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.find_valid_node_path-Tuple{PhyloNetworks.HybridNetwork, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.find_valid_node_path","text":"Helper function that finds a path in net from nodei to nodej. If that path has 2 or more reticulations in it, the cost to include a hybrid in the path is incrementally increased until only 1 reticulation is in the path.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.findoptQidx-Tuple{AbstractMatrix{Float64}, BitArray, AbstractVector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.findoptQidx","text":"findoptQ(D::Matrix{Float64}, idxpairs::Vector{Tuple{<:Integer, <:Integer}})\n\nFinds the minimizer (i, j) among all pairs (i, j) in idxpairs for Q, a matrix computed from D.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.findsiblingpairs-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.findsiblingpairs","text":"findsiblingpairs(net::HybridNetwork)\n\nFinds sibling pairings for all the leaves in a single network. These pairs are valid for net but may not be valid when the     other constraint networks are also considered. Returns a vector of tuples of nodes corresponding to siblings.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.findvalidpairs-Tuple{Vector{PhyloNetworks.HybridNetwork}, Any, AbstractVector{<:AbstractString}}","page":"Documentation","title":"InPhyNet.findvalidpairs","text":"findvalidpairs(constraints::Vector{HybridNetwork}, constraint_sibling_pairs, namelist::AbstractVector{<:AbstractString})\n\nFinds all valid sibling pairs among the constraint networks.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.fuseredundantedges!-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.fuseredundantedges!","text":"Helper function to remove redundant edges (e.g. A â€“> (internal node) â€“> (internal node)) that arise from one case of the function mergeconstraintnodes!.\n\nRedundant nodes in this case will always have only two edges while not being the root.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.gather_hyb_descendants_outside_of_path-Tuple{PhyloNetworks.Node, Array{PhyloNetworks.Node}}","page":"Documentation","title":"InPhyNet.gather_hyb_descendants_outside_of_path","text":"Helper function used at one point in mergeconstraintnodes!. Gets all of the descendants of node that do not have any children and are not in path\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.getLeavesUnderEdge-Tuple{PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Documentation","title":"InPhyNet.getLeavesUnderEdge","text":"Gets all the leaf nodes underneath edge edge.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.getLongestBranch-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.getLongestBranch","text":"Gets the longest edge in tre.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.getMidSplitEdge-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.getMidSplitEdge","text":"Finds a branch in tre that, when pruned on, splits the tree roughly in half.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.get_neighbor_set-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.get_neighbor_set","text":"Gets the set of neighbors in network net. Only implemented for trees right now.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.getsiblingcandidates-Tuple{PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.getsiblingcandidates","text":"A helper function that finds other nodes in the net that leaf belongs to that may be its sibling. This function sees past reticulations, so that e.g. in ((A,(B,#H1)),((C)#H1,D)) B and C will be     marked as siblings.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.has_direct_root_connection-Tuple{PhyloNetworks.HybridNetwork, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.has_direct_root_connection","text":"Helper function - returns true if the node node is connected directly to the root of net, or if the path connecting node to net's root is multiple redundant edges (e.g. returns true for A in the net: \"((((((A))))), (B,C));\")\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.inany-Tuple{AbstractString, Vector{Vector{String}}}","page":"Documentation","title":"InPhyNet.inany","text":"Helper function that finds whether name is listed in any subset in subsets\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.inphynet-2","page":"Documentation","title":"InPhyNet.inphynet","text":"Runs the InPhyNet algorithm on the given distance matrix and constraint networks where the entries in namelist correspond to indices in D.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#InPhyNet.internodecount-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.internodecount","text":"internodecount(N::HybridNetwork; namelist::Union{Nothing,<:AbstractVector{String}}=nothing)\n\nCalculates internode counts between all pairs of taxa in network N. WARNING: treats N as unrooted\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.internodedistance-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.internodedistance","text":"internodedistance(N::HybridNetwork; namelist::Union{Nothing,<:AbstractVector{String}}=nothing)\n\nCalculates internode distance between all pairs of taxa in network N.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.kconnected-Tuple{AbstractVector{<:AbstractString}, Vector{<:AbstractString}, Vector{Vector{String}}}","page":"Documentation","title":"InPhyNet.kconnected","text":"Takes minsubset, a subset defined in the function minimumuniquesubset, and, for each entry i of minsubset, gathers the k-1 taxa that i appears with most often across all quartets.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.log_edge_path_retics_from_node-Tuple{PhyloNetworks.Node, AbstractVector{PhyloNetworks.EdgeT{PhyloNetworks.Node}}, Bool, Bool, Union{Nothing, PhyloNetworks.EdgeT{PhyloNetworks.Node}}, InPhyNet.ReticMap, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.HybridNetwork, Bool, AbstractVector{PhyloNetworks.Node}, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.log_edge_path_retics_from_node","text":"Helper function\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.major_mrca-Tuple{PhyloNetworks.Node, PhyloNetworks.Node, PhyloNetworks.Node}","page":"Documentation","title":"InPhyNet.major_mrca","text":"Gets the MRCA of nodei and nodej along their major tree.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.majorinternodecount-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.majorinternodecount","text":"majorinternodecount(N::HybridNetwork)\n\nCalculates major internode counts between all pairs of taxa in the major displayed tree of network N. If N is a tree, then internode counts are as expected for a tree.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.majorinternodedistance-Tuple{PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.majorinternodedistance","text":"majorinternodedistance(N::HybridNetwork)\n\nCalculates internode distances between all pairs of taxa in the major displayed tree of network N. If N is a tree, then internode distances are as expected for a tree.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.mergesubnets!-Tuple{InPhyNet.SubNet, InPhyNet.SubNet}","page":"Documentation","title":"InPhyNet.mergesubnets!","text":"Merges two unrooted SubNets into a single unrooted SubNet Returns the merged subnet AND the edges in the merged net     corresponding to where reticulations will be placed if there     are corresponding reticulations discovered in the constraints.\n\nIMPORTANT: this function should NOT make copies of edges or     nodes, object references are stored and used in     the main merging algorithm\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.minimumuniquesubset-Tuple{AbstractVector{<:AbstractString}, Vector{Vector{String}}}","page":"Documentation","title":"InPhyNet.minimumuniquesubset","text":"Finds the smallest subset S of names in namelist such that every quartet in R has at least one of its taxa in S.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.parsequartets-Tuple{AbstractString}","page":"Documentation","title":"InPhyNet.parsequartets","text":"Reads output from MSCquartets in R and parses it so that it can be used efficiently with our julia code.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.parsequartets-Tuple{DataFrames.DataFrame}","page":"Documentation","title":"InPhyNet.parsequartets","text":"Reads output from MSCquartets in R and parses it so that it can be used efficiently with our julia code.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.placeretics!-Tuple{PhyloNetworks.HybridNetwork, InPhyNet.ReticMap, Any}","page":"Documentation","title":"InPhyNet.placeretics!","text":"Updates net to include the reticulations that we've kept track of along the way in our algo but haven't placed yet.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.pruneTruthFromDecomp-Tuple{PhyloNetworks.HybridNetwork, AbstractVector{<:AbstractVector{<:AbstractString}}}","page":"Documentation","title":"InPhyNet.pruneTruthFromDecomp","text":"Returns a list of networks where each entry is a copy of truenet pruned to include only the taxa named in each respective set in subsets.\n\nExample\n\nmynetwork = readnewick(\"((t1,t2),(t3,t4));\")\npruneTruthFromDecomp(mynetwork, [[\"t1\", \"t2\"], [\"t3\", \"t4\"]])\n> 2-element Vector{HybridNetwork}: (t1, t2); and (t3, t4);\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.removeredundantedges!-Tuple{Graphs.SimpleGraphs.SimpleGraph, PhyloNetworks.HybridNetwork}","page":"Documentation","title":"InPhyNet.removeredundantedges!","text":"Helper function that removes redundant edges in the graph that exist when some hybrids are pruned from the graph.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.requiredhybridsubsets-Tuple{AbstractVector{<:AbstractString}, Vector{Vector{String}}}","page":"Documentation","title":"InPhyNet.requiredhybridsubsets","text":"Current base subset decomposition schema. First, we find the smallest subset S of names such that all quartets have at least one taxa in the subset. Then, for each entry of S, we gather the set of 3 other taxa it appears with most often in the quartets in R.\n\nThe idea behind these subsets is to guarantee identifiability of hybridizations, hence why they are required.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.root_constraints!-Tuple{Vector{PhyloNetworks.HybridNetwork}}","page":"Documentation","title":"InPhyNet.root_constraints!","text":"If any constraints are unrooted, picks a root node from any node directly under the root (somewhat randomly).\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.sateIIdecomp-Tuple{PhyloNetworks.HybridNetwork, Integer}","page":"Documentation","title":"InPhyNet.sateIIdecomp","text":"Performs subset decomposition as outlined in SATe-II on inittree.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.sateIdecomp-Tuple{PhyloNetworks.HybridNetwork, Integer, Integer}","page":"Documentation","title":"InPhyNet.sateIdecomp","text":"Slightly adjusted implementation of the decomposition algorithm from SATe-I that takes a maximum and a minimum subset size.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.sateIdecomp-Tuple{PhyloNetworks.HybridNetwork, Integer}","page":"Documentation","title":"InPhyNet.sateIdecomp","text":"Performs subset decomposition as outlines in SATe-I on inittree. Returns vector of vector of names, e.g. [[\"a\", \"b\"], [\"c\", \"d\", \"e\"]]\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.splitAtEdge-Tuple{PhyloNetworks.HybridNetwork, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Documentation","title":"InPhyNet.splitAtEdge","text":"Splits tre into two trees at its longest branch.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.updateconstraints!-Tuple{AbstractString, AbstractString, Vector{PhyloNetworks.HybridNetwork}, InPhyNet.ReticMap, PhyloNetworks.EdgeT{PhyloNetworks.Node}, PhyloNetworks.EdgeT{PhyloNetworks.Node}}","page":"Documentation","title":"InPhyNet.updateconstraints!","text":"Updates constraint networks after (i, j) with names (nodenamei, nodenamej) have been merged. Also updates reticmap to keep track of any reticulations that get removed in this process.\n\nBy convention we keep nodenamei and replace node names with nodenamej\n\n\n\n\n\n","category":"method"},{"location":"documentation/#InPhyNet.vecreplace!-Union{Tuple{T}, Tuple{Vector{T}, T, T}} where T","page":"Documentation","title":"InPhyNet.vecreplace!","text":"Helper function for manipulating graph adjacency lists.\n\n\n\n\n\n","category":"method"}]
}
