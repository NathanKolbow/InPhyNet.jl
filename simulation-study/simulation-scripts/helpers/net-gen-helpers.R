# Helper functions

# Networks generated by `SiPhyNetwork` have an edge
# above the root; we want to remove that.
#
# Takes a list of network objects *BUT RETURNS
# A VECTOR OF STRINGS*
fix_subnet_roots <- function(subnet_list) {
    newick_vector <- c()
    for(idx in 1:length(subnet_list)) {
        newick <- write.net(subnet_list[[idx]])
        str_idx <- regexpr(":[0-9]*\\.[0-9]*);", newick)
        newick <- paste0(str_sub(newick, 2, as.integer(str_idx) - 1), ";")
        newick_vector <- c(newick_vector, newick)
    }
    newick_vector
}

# Rename the retics in `subnet_newick` to "#HX"
# with X starting at `retic_idx` and incrementing by 1.
rename_retics <- function(subnet_newick, retic_idx) {
    temp_idx <- retic_idx
    regex_result <- regexpr("#H[0-9]*:", subnet_newick)
    while(regex_result != -1) {
        start_idx <- as.integer(regex_result)
        end_idx <- start_idx + attr(regex_result, "match.length") - 2   # -2 so we don't include ":"

        matching_substring <- str_sub(subnet_newick, start_idx, end_idx)
        subnet_newick <- str_replace_all(subnet_newick, matching_substring, paste0("__RETIC", temp_idx, "__"))
        temp_idx <- temp_idx + 1

        regex_result <- regexpr("#H[0-9]*:", subnet_newick)
    }

    while(retic_idx < temp_idx) {
        subnet_newick <- str_replace_all(subnet_newick, paste0("__RETIC", retic_idx, "__"), paste0("#H", retic_idx))
        retic_idx <- retic_idx + 1
    }

    return(subnet_newick)
}

# Rename the tips to "tX", where X is from 1-N.
#
# For some reason a copy of the list of subnets is passed
# as an argument, not a reference. Probably b/c it's a
# custom data type that isn't optimally implemented. So,
# we return the list instead of operating on it in-place.
rename_subnet_tips <- function(subnet_list, subnet_size, nretic) {
    # Rename tips so that labels are unique across all subnets
    ntaxa <- length(subnet_list) * subnet_size
    namelist <- paste0("t", 1:ntaxa)
    name_idx <- 1

    for(subnet_idx in 1:length(subnet_list)) {
        subnet_list[[subnet_idx]]$tip.label <- namelist[name_idx:(name_idx+(subnet_size-1))]
        name_idx <- name_idx + subnet_size
    }

    return(subnet_list)
}

# Generates the tree structure used to place subnets.
generate_tree <- function(ntips) {
    sim.bdh.taxa.ssa(
        n = ntips, numbsim = 1, nu = 0, hybprops = c(1, 0, 0),
        mu = 0, hyb.inher.fxn = make.beta.draw(10, 10), lambda = 1
    )[[1]]
}

# Generates subnets to be fitted into the tree generated
# w/ generate_tree. `n_subnets` is the number of networks
# to be generated, `n_taxa` is the number of taxa in
# *each subnet*.
#
# `n_retics_total` is the number of total reticulations
# *across all subnets*.
generate_subnets <- function(n_subnets, n_taxa, n_retics_total, nu) {
    total_runs <- 0
    while(TRUE) {
        total_runs <- total_runs + 1
        if(total_runs > 1e5) {
            cat("1e5 runs w/o success, quitting.\n")
            return(-1)
        }

        nets <- sim.bdh.taxa.ssa(
            n = n_taxa, numbsim = n_subnets, nu = nu, hybprops = c(0.5, 0, 0.5),
            mu = 0, hyb.inher.fxn = make.beta.draw(10, 10),
            lambda = 1
        )
        if(any_failures(nets)) { next }
        
        nhybs_total <- sum(getnhybs(nets))
        if(nhybs_total == n_retics_total) {
            return(list(subnets=nets, nu=nu))
        } else if(nhybs_total < n_retics_total) {
            nu <- 1.5 * nu
        } else {
            nu <- 2 * nu / 3
        }
    }
}

# Generates subnets to be fitted into the tree generated
# w/ generate_tree. `n_subnets` is the number of networks
# to be generated, `n_taxa` is the number of taxa in
# *each subnet*.
#
# `n_retics_total` is the number of total reticulations
# *across all subnets*.
generate_subnets_level1 <- function(n_subnets, n_taxa, nu) {
    subnets <- list()
    for(subnet_idx in 1:n_subnets) {
        total_runs <- 0
        while(TRUE) {
            if(total_runs > 1e5) {
                cat("1e5 runs w/o success, quitting.\n")
                return(-1)
            }

            nets <- sim.bdh.taxa.ssa(
                n = n_taxa, numbsim = 25, nu = nu, hybprops = c(0.5, 0, 0.5),
                mu = 0, hyb.inher.fxn = make.beta.draw(10, 10), lambda = 1
            )
            total_runs <- total_runs + 25
            
            nhybs <- getnhybs(nets)
            min_lvl <- 100
            min_net <- -1
            for(i in 1:25) {
                if(length(nets[[i]]) == 0) { next }
                iter_lvl <- getNetworkLevel(nets[[i]])
                if(iter_lvl < min_lvl) {
                    min_lvl <- iter_lvl
                    min_net <- nets[[i]]
                }
            }

            if(min_lvl <= 1) {
                subnets[[subnet_idx]] <- min_net
                break
            } else {
                nu <- nu * 5 / 6
            }
        }
    }
    return(list(subnets=subnets, nu=nu))
}

# Did any of the network simulations fail?
any_failures <- function(net_list) {
    any(unlist(lapply(
        net_list, is.numeric
    )))
}

getnhybs <- function(ssa_nets) {
    nhyblist <- c()
    for(i in 1:length(ssa_nets)) {
        if(!is.numeric(ssa_nets[[i]])) {
            nhybs <- dim(ssa_nets[[i]]$reticulation)[1]
            nhyblist <- c(nhyblist, nhybs)
        }
    }
    return(nhyblist)
}

findnu <- function(ntaxa, goalhybs) {
    nu <- 0.1
    ssa_nets_hybs <- c(goalhybs + 100)
    while(!(mean(ssa_nets_hybs) < goalhybs + 1)) {
        nu <- nu - nu / 10
        ssa_nets <- sim.bdh.taxa.ssa(
            n=ntaxa, numbsim=100, nu=nu, hybprops=c(0.5, 0, 0.5),
            mu=0, hyb.inher.fxn=make.beta.draw(10, 10),
            lambda=1
        )
        ssa_nets_hybs <- getnhybs(ssa_nets)
    }
    return(nu)
}

findnets <- function(ntaxa, nu, goalhybs, maxlevel) {
    idx <- 1
    nets <- sim.bdh.taxa.ssa(   # placeholder nets
            n = ntaxa, numbsim = 1, nu = nu, hybprops = c(0.5, 0, 0.5),
            mu = 0, hyb.inher.fxn = make.beta.draw(10, 10),
            lambda = 1
        )

    while (idx <= 100) {
        net <- sim.bdh.taxa.ssa(
            n = ntaxa, numbsim = 1, nu = nu, hybprops = c(0.5, 0, 0.5),
            mu = 0, hyb.inher.fxn = make.beta.draw(10, 10),
            lambda = 1
        )

        if(!is.numeric(net[[1]]) && getNetworkLevel(net[[1]]) <= maxlevel && getnhybs(net) == goalhybs) {
            nets[[idx]] <- net[[1]]
            cat(paste0("\rFound ", idx, " networks."))
            idx <- idx + 1
        }
    }
    cat("\n")
    return(nets)
}

telap <- function(st_ti) round(difftime(Sys.time(), st_ti, units = "secs"), 2)
findlowestlevel <- function(ntaxa, nu, goalhybs, searchiters = 1e4, shouldprint = T) {
    minlvl <- Inf
    minlvlcount <- 0
    start_time <- Sys.time()
    total_generated_nets <- 0

    while (total_generated_nets < searchiters) {
        net <- sim.bdh.taxa.ssa(
            n = ntaxa, numbsim = 1, nu = nu, hybprops = c(0.5, 0, 0.5),
            mu = 0, hyb.inher.fxn = make.beta.draw(10, 10),
            lambda = 1
        )
        total_generated_nets <- total_generated_nets + 1

        if(!is.numeric(net[[1]]) && getnhybs(net) == goalhybs) {
            currlvl <- getNetworkLevel(net[[1]])
            if(currlvl < minlvl) {
                minlvl <- currlvl
                minlvlcount <- 1
            } else if(currlvl == minlvl) {
                minlvlcount <- minlvlcount + 1
            }
        }

        if(shouldprint && total_generated_nets %% 100 == 0) {
            t_elap <- round(telap(start_time), 2)
            cat(paste0("\r", total_generated_nets, " generated in ", t_elap, " seconds "))
            est_total_time <- round(t_elap / (total_generated_nets / searchiters), 2)
            cat(paste0("(est. ", est_total_time, "s == ", round(est_total_time / 60, 2), "m)                "))
        }
    }
    if(shouldprint) {
        cat(paste0("\nSearch ", total_generated_nets, " in ", round(telap(start_time) / 60, 2), " minutes.\n"))
    }
    return(minlvl)
}

# Find networks
findandsavenets <- function(ntaxa, prod, maxlevel = 1, searchiters = -1) {
    set.seed(42)

    goalhybs <- floor(ntaxa * prod)
    cat("\rSearching for nu value...")
    nu <- findnu(ntaxa, goalhybs)
    cat(paste0("\rFound nu value: ", nu, "                        \n"))

    if(maxlevel == 1 && searchiters != -1) {
        cat(paste0("Searching for appropriate maximum level with ", searchiters, " iterations...\n"))
        maxlevel <- findlowestlevel(ntaxa, nu, goalhybs, searchiters = searchiters)
        print(paste0("Setting max level: ", maxlevel))
    }

    nets <- findnets(ntaxa, nu, goalhybs, maxlevel = maxlevel)
    write.net(nets, file=paste0(basedir, "simulation-study/data/networks/n", ntaxa, "r", goalhybs, ".netfile"))
}